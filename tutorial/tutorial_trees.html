<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Working with the Tree structure &#8212; ETE Toolkit 4.0.0-beta2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=382e6e0c"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Phylogenetic trees" href="tutorial_phylogeny.html" />
    <link rel="prev" title="Tutorial" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="working-with-the-tree-structure">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">Working with the Tree structure</a><a class="headerlink" href="#working-with-the-tree-structure" title="Link to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#working-with-the-tree-structure" id="id1">Working with the Tree structure</a></p>
<ul>
<li><p><a class="reference internal" href="#trees" id="id2">Trees</a></p></li>
<li><p><a class="reference internal" href="#reading-and-writing-newick-trees" id="id3">Reading and writing newick trees</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-a-tree" id="id4">Creating a tree</a></p></li>
<li><p><a class="reference internal" href="#reading-newick-trees" id="id5">Reading newick trees</a></p></li>
<li><p><a class="reference internal" href="#writing-newick-trees" id="id6">Writing newick trees</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#understanding-ete-trees" id="id7">Understanding ETE trees</a></p></li>
<li><p><a class="reference internal" href="#basic-tree-attributes" id="id8">Basic tree attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#the-meaning-of-the-root-node-in-unrooted-trees" id="id9">The meaning of the “root node” in unrooted trees</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#browsing-trees-traversing" id="id10">Browsing trees (traversing)</a></p>
<ul>
<li><p><a class="reference internal" href="#getting-leaves-descendants-and-node-s-relatives" id="id11">Getting leaves, descendants and node’s relatives</a></p></li>
<li><p><a class="reference internal" href="#traversing-browsing-trees" id="id12">Traversing (browsing) trees</a></p></li>
<li><p><a class="reference internal" href="#advanced-traversing" id="id13">Advanced traversing</a></p>
<ul>
<li><p><a class="reference internal" href="#collapsing-nodes-while-traversing" id="id14">Collapsing nodes while traversing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#iterators-or-lists" id="id15">Iterators or lists?</a></p></li>
<li><p><a class="reference internal" href="#finding-nodes-by-their-properties" id="id16">Finding nodes by their properties</a></p>
<ul>
<li><p><a class="reference internal" href="#search-all-nodes-matching-a-given-criteria" id="id17">Search all nodes matching a given criteria</a></p></li>
<li><p><a class="reference internal" href="#search-nodes-matching-a-given-criteria" id="id18">Search nodes matching a given criteria</a></p></li>
<li><p><a class="reference internal" href="#find-the-first-common-ancestor" id="id19">Find the first common ancestor</a></p></li>
<li><p><a class="reference internal" href="#custom-searching-functions" id="id20">Custom searching functions</a></p></li>
<li><p><a class="reference internal" href="#shortcuts" id="id21">Shortcuts</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#checking-the-monophyly-of-properties-within-a-tree" id="id22">Checking the monophyly of properties within a tree</a></p></li>
<li><p><a class="reference internal" href="#caching-tree-content-for-faster-lookup-operations" id="id23">Caching tree content for faster lookup operations</a></p></li>
<li><p><a class="reference internal" href="#node-annotation" id="id24">Node annotation</a></p></li>
<li><p><a class="reference internal" href="#comparing-trees" id="id25">Comparing trees</a></p>
<ul>
<li><p><a class="reference internal" href="#distances-between-trees" id="id26">Distances between trees</a></p></li>
<li><p><a class="reference internal" href="#robinson-foulds-distance" id="id27">Robinson-Foulds distance</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#modifying-tree-topology" id="id28">Modifying tree topology</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-trees-from-scratch" id="id29">Creating trees from scratch</a></p></li>
<li><p><a class="reference internal" href="#how-to-delete-eliminate-or-remove-detach-nodes" id="id30">How to delete/eliminate or remove/detach nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pruning-trees" id="id31">Pruning trees</a></p></li>
<li><p><a class="reference internal" href="#concatenating-trees" id="id32">Concatenating trees</a></p></li>
<li><p><a class="reference internal" href="#copying-duplicating-trees" id="id33">Copying (duplicating) trees</a></p></li>
<li><p><a class="reference internal" href="#solving-multifurcations" id="id34">Solving multifurcations</a></p></li>
<li><p><a class="reference internal" href="#tree-rooting" id="id35">Tree rooting</a></p></li>
<li><p><a class="reference internal" href="#working-with-branch-distances" id="id36">Working with branch distances</a></p>
<ul>
<li><p><a class="reference internal" href="#getting-distances-between-nodes" id="id37">Getting distances between nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#getting-midpoint-outgroup" id="id38">Getting midpoint outgroup</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="trees">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Trees</a><a class="headerlink" href="#trees" title="Link to this heading">¶</a></h2>
<p>Trees are a widely-used type of data structure that emulates a tree
design with a set of linked nodes. Formally, a tree is considered an
acyclic and connected graph. Each node in a tree has zero or more
child nodes, which are below it in the tree (by convention, trees grow
down, not up as they do in nature). A node that has a child is called
the child’s parent node (or ancestor node, or superior). A node has at
most one parent.</p>
<p>The height of a node is the length of the longest downward path to a
leaf from that node. The height of the root is the height of the tree.
The depth of a node is the length of the path to its root (i.e., its
root path).</p>
<ul class="simple">
<li><p>The topmost node in a tree is called the root node. Being the
topmost node, the root node will not have parents. It is the node at
which operations on the tree commonly begin (although some
algorithms begin with the leaf nodes and work up ending at the
root). All other nodes can be reached from it by following edges or
links. Every node in a tree can be seen as the root node of the
subtree rooted at that node.</p></li>
<li><p>Nodes at the bottommost level of the tree are called leaf nodes.
Since they are at the bottommost level, they do not have any
children.</p></li>
<li><p>An internal node or inner node is any node of a tree that has child
nodes and is thus not a leaf node.</p></li>
<li><p>A subtree is a portion of a tree data structure that can be viewed
as a complete tree in itself. Any node in a tree T, together with
all the nodes below it, comprise a subtree of T. The subtree
corresponding to the root node is the entire tree; the subtree
corresponding to any other node is called a proper subtree (in
analogy to the term proper subset).</p></li>
</ul>
<p>In bioinformatics, trees are the result of many analyses, such as
phylogenetics or clustering. Although each case entails specific
considerations, many properties remains constant among them. In this
respect, ETE is a python toolkit that assists in the automated
manipulation, analysis and visualization of any type of hierarchical
trees. It provides general methods to handle and visualize tree
topologies, as well as specific modules to deal with phylogenetic and
clustering trees.</p>
</section>
<section id="reading-and-writing-newick-trees">
<span id="sec-newick-formats"></span><h2><a class="toc-backref" href="#id3" role="doc-backlink">Reading and writing newick trees</a><a class="headerlink" href="#reading-and-writing-newick-trees" title="Link to this heading">¶</a></h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Newick_format">Newick format</a> is
one of the most widely used standard representations of trees in
bioinformatics. It uses nested parentheses to represent hierarchical
data structures as text strings. The original newick standard is able
to encode information about the tree topology, branch distances and
node names. Nevertheless, it is not uncommon to find slightly
different variations of the format.</p>
<p>ETE can read and write many of them:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Format</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>internal nodes with support (flexible)</p></td>
<td><p>((D:0.7,F:0.5)1.0:0.6,(B:0.2,H:0.7)1.0:0.8);</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>internal nodes with names (flexible)</p></td>
<td><p>((D:0.7,F:0.5)E:0.6,(B:0.2,H:0.7)B:0.8);</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>internal w/ support, all lengths present</p></td>
<td><p>((D:0.7,F:0.5)1.0:0.6,(B:0.2,H:0.7)1.0:0.8);</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>internal w/ names, all lengths present</p></td>
<td><p>((D:0.7,F:0.5)E:0.6,(B:0.2,H:0.7)B:0.8);</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>names and lengths for leaves only</p></td>
<td><p>((D:0.7,F:0.5),(B:0.2,H:0.7));</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>leaf names and all lengths</p></td>
<td><p>((D:0.7,F:0.5):0.6,(B:0.2,H:0.7):0.8);</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>leaf names and internal lengths</p></td>
<td><p>((D,F):0.6,(B,H):0.8);</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>all names and leaf lengths</p></td>
<td><p>((D:0.7,F:0.5)E,(B:0.2,H:0.7)B);</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>all names (leaves and internal nodes)</p></td>
<td><p>((D,F)E,(B,H)B);</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>leaf names only</p></td>
<td><p>((D,F),(B,H));</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>topology only</p></td>
<td><p>((,),(,));</p></td>
</tr>
</tbody>
</table>
<p>Formats labeled as <em>flexible</em> allow for missing information. For
instance, format 0 will be able to load a newick tree even if it does
not contain branch support information. However, format 2 would raise
an exception. In other words, if you want to control that your newick
files strictly follow a given pattern you can use <strong>strict</strong> format
definitions.</p>
<section id="creating-a-tree">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Creating a tree</a><a class="headerlink" href="#creating-a-tree" title="Link to this heading">¶</a></h3>
<p>ETE’s class <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree" title="ete4.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a>, provided by the main module <code class="xref py py-mod docutils literal notranslate"><span class="pre">ete4</span></code>,
can be used to construct trees. You can create a single node by
calling <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree" title="ete4.Tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree()</span></code></a> without any arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ete4</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c1"># Empty tree (single node).</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
</pre></div>
</div>
<p>Or you can call it with a dictionary specifying the properties of that
single node. You can also use the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.populate" title="ete4.Tree.populate"><code class="xref py py-func docutils literal notranslate"><span class="pre">populate</span></code></a>
method to populate a tree with a random topology:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ete4</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c1"># Also a single node, but with some properties.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;support&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;coolness&#39;</span><span class="p">:</span> <span class="s1">&#39;high&#39;</span><span class="p">})</span>

<span class="c1"># Populate t with a random topology of size 10.</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>(In all the examples we will want to write <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">ete4</span> <span class="pre">import</span> <span class="pre">Tree</span></code>
first to use the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree" title="ete4.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a> class, as we did above. In the
remaining examples we will assume that you have already imported it.)</p>
<p>The properties of a node are stored in its <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.props" title="ete4.Tree.props"><code class="xref py py-attr docutils literal notranslate"><span class="pre">props</span></code></a>
dictionary. With the previous example, writing <code class="docutils literal notranslate"><span class="pre">print(t.props)</span></code> will
show us a dictionary that should look familiar. And if you
<code class="docutils literal notranslate"><span class="pre">print(t)</span></code> a tree, you will see a simple visualization. For our
example of the previously populated tree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>  <span class="c1"># where the properties of a node are stored</span>
<span class="c1"># {&#39;name&#39;: &#39;root&#39;, &#39;dist&#39;: 1.0, &#39;support&#39;: 0.5, &#39;coolness&#39;: &#39;high&#39;}</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># will look more or less like:</span>
<span class="c1">#  ╭─┬╴a</span>
<span class="c1">#  │ ╰╴b</span>
<span class="c1"># ─┤ ╭─┬╴c</span>
<span class="c1">#  │ │ ╰─┬╴d</span>
<span class="c1">#  ╰─┤   ╰─┬╴e</span>
<span class="c1">#    │     ╰╴f</span>
<span class="c1">#    ╰─┬╴g</span>
<span class="c1">#      ╰─┬╴h</span>
<span class="c1">#        ╰─┬╴i</span>
<span class="c1">#          ╰╴j</span>
</pre></div>
</div>
</section>
<section id="reading-newick-trees">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Reading newick trees</a><a class="headerlink" href="#reading-newick-trees" title="Link to this heading">¶</a></h3>
<p>To load a tree from a newick text string you can pass to <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree" title="ete4.Tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree()</span></code></a>
the text string containing the newick structure. Alternatively, you
can pass a file object that contains the newick string. And
optionally, you can also specify the format that should be used to
parse it (0 by default, see <a class="reference internal" href="#sec-newick-formats"><span class="std std-ref">Reading and writing newick trees</span></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a tree structure from a newick string. It returns the root node.</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A:1,(B:1,(E:1,D:1):0.5):0.5);&#39;</span><span class="p">)</span>

<span class="c1"># Load a tree structure from a newick file.</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;genes_tree.nw&#39;</span><span class="p">))</span>

<span class="c1"># You can also specify how to parse the newick. For instance,</span>
<span class="c1"># internal nodes by default are interpreted as support values</span>
<span class="c1"># (parser=0), but we can interpret them as names with parser=1.</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A:1,(B:1,(E:1,D:1)E:0.5)F:0.5);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="writing-newick-trees">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Writing newick trees</a><a class="headerlink" href="#writing-newick-trees" title="Link to this heading">¶</a></h3>
<p>Any ETE tree instance can be exported using newick notation using the
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.write" title="ete4.Tree.write"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.write()</span></code></a> method. It also allows for parser selection, so you
can use the same function to convert between newick formats.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a tree with internal names.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A:1,(B:1,(E:1,D:1)E:0.5)F:0.5);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print its newick using the default parser.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">())</span>  <span class="c1"># (A:1,(B:1,(E:1,D:1):0.5):0.5);</span>

<span class="c1"># To print the internal names you can change the parser.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># (A:1,(B:1,(E:1,D:1)E:0.5)F:0.5);</span>

<span class="c1"># We can also write into a file.</span>
<span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;new_tree.nw&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="understanding-ete-trees">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Understanding ETE trees</a><a class="headerlink" href="#understanding-ete-trees" title="Link to this heading">¶</a></h2>
<p>Any tree topology can be represented as a succession of <strong>nodes</strong>
connected in a hierarchical way. Thus, for practical reasons, ETE
makes no distinction between the concepts of tree and node, as any
tree can be represented by its root node. This allows to use any
internal node within a tree as another sub-tree instance.</p>
<p>Once trees are loaded, they can be manipulated as normal python
objects. Given that a tree is actually a collection of nodes connected
in a hierarchical way, what you usually see as a tree will be the root
node instance from which the tree structure is hanging. However, every
node within a ETE’s tree structure can be also considered a subtree.
This means, for example, that all the operational methods that we will
review in the following sections are available at any possible level
within a tree. Moreover, this feature will allow you to separate large
trees into smaller partitions, or concatenate several trees into a
single structure.</p>
</section>
<section id="basic-tree-attributes">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Basic tree attributes</a><a class="headerlink" href="#basic-tree-attributes" title="Link to this heading">¶</a></h2>
<p>Each tree node has two basic attributes used to establish its position
in the tree: <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.up" title="ete4.Tree.up"><code class="xref py py-attr docutils literal notranslate"><span class="pre">up</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.children" title="ete4.Tree.children"><code class="xref py py-attr docutils literal notranslate"><span class="pre">children</span></code></a>. The first is a pointer to its parent’s node, while
the latter is a list of children nodes. Although it is possible to
modify the structure of a tree by changing these attributes, it is
strongly recommend not to do it. Several methods are provided to
manipulate each node’s connections in a safe way (see
<a class="reference internal" href="#sec-modifying-tree-topology"><span class="std std-ref">Modifying tree topology</span></a>).</p>
<p>In addition, three other basic attributes are always present in any
tree node instance (let’s call it <code class="docutils literal notranslate"><span class="pre">node</span></code>):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.dist</span></code></p></td>
<td><p>Distance from the node to its parent (branch length)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.support</span></code></p></td>
<td><p>Reliability of the partition defined by the node (like bootstrap support)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.name</span></code></p></td>
<td><p>Node’s name</p></td>
</tr>
</tbody>
</table>
<p>In addition, several methods are provided to perform basic operations
on tree node instances:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.is_leaf</span></code></p></td>
<td><p>True if node has no children</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.is_root</span></code></p></td>
<td><p>True if node has no parent</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">node.root</span></code></p></td>
<td><p>The top-most node within the same tree structure as node</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">len(node)</span></code></p></td>
<td><p>Returns the number of leaves under node</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">print(node)</span></code></p></td>
<td><p>Prints a text-based representation of the tree topology under node</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">n</span> <span class="pre">in</span> <span class="pre">node</span></code></p></td>
<td><p>True if <em>n</em> is a leaf under node</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">for</span> <span class="pre">leaf</span> <span class="pre">in</span> <span class="pre">node</span></code></p></td>
<td><p>Iterates over all leaves under node</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">node.explore()</span></code></p></td>
<td><p>Explore node graphically using a GUI</p></td>
</tr>
</tbody>
</table>
<p>This is an example on how to access such attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a random tree topology.</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># text visualization of the tree</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>  <span class="c1"># list of children nodes directly hanging from the root</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">up</span><span class="p">)</span>  <span class="c1"># should be None, since t is the root</span>

<span class="c1"># You can also iterate over tree leaves using a simple syntax.</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>  <span class="c1"># take the first leaf</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;First leaf name:&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;First leaf distance:&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;t.is_leaf = </span><span class="si">%s</span><span class="s1">   n.is_leaf = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">root</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">root</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># True too</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">root</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># and True again</span>
</pre></div>
</div>
<section id="the-meaning-of-the-root-node-in-unrooted-trees">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">The meaning of the “root node” in unrooted trees</a><a class="headerlink" href="#the-meaning-of-the-root-node-in-unrooted-trees" title="Link to this heading">¶</a></h3>
<p>When a tree is loaded from external sources, a pointer to the top-most
node is returned. This is called the tree root, and <strong>it will exist
even if the tree is conceptually considered as unrooted</strong>. That is,
the root node can be considered as the master node, since it
represents the whole tree structure.</p>
<p>ETE will consider that a tree is “unrooted” if the master root node
has more than two children.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unrooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A,B,(C,D));&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unrooted_tree</span><span class="p">)</span>
<span class="c1">#  ╭╴A</span>
<span class="c1"># ─┼╴B</span>
<span class="c1">#  ╰─┬╴C</span>
<span class="c1">#    ╰╴D</span>

<span class="n">rooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((A,B),(C,D));&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rooted_tree</span><span class="p">)</span>
<span class="c1">#  ╭─┬╴A</span>
<span class="c1"># ─┤ ╰╴B</span>
<span class="c1">#  ╰─┬╴C</span>
<span class="c1">#    ╰╴D</span>
</pre></div>
</div>
</section>
</section>
<section id="browsing-trees-traversing">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Browsing trees (traversing)</a><a class="headerlink" href="#browsing-trees-traversing" title="Link to this heading">¶</a></h2>
<p>One of the most basic operations for tree analysis is <em>tree browsing</em>.
This is, essentially, visiting nodes within a tree. ETE provides a
number of methods to search for specific nodes or to navigate over the
hierarchical structure of a tree.</p>
<section id="getting-leaves-descendants-and-node-s-relatives">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Getting leaves, descendants and node’s relatives</a><a class="headerlink" href="#getting-leaves-descendants-and-node-s-relatives" title="Link to this heading">¶</a></h3>
<p>Tree instances contain several functions to access their descendants.
Available methods are self explanatory:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.descendants" title="ete4.Tree.descendants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.descendants</span></code></a>(self[, strategy, is_leaf_fn])</p></td>
<td><p>Yield all descendant nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.ancestors" title="ete4.Tree.ancestors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.ancestors</span></code></a>(self[, root, include_root])</p></td>
<td><p>Yield all ancestor nodes of this node (up to the root if given).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.leaves" title="ete4.Tree.leaves"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.leaves</span></code></a>(self[, is_leaf_fn])</p></td>
<td><p>Yield the terminal nodes (leaves) under this node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.leaf_names" title="ete4.Tree.leaf_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.leaf_names</span></code></a>(self[, is_leaf_fn])</p></td>
<td><p>Yield the leaf names under this node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_children" title="ete4.Tree.get_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.get_children</span></code></a>(self)</p></td>
<td><p>Return an independent list of the node's children.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_sisters" title="ete4.Tree.get_sisters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.get_sisters</span></code></a>(self)</p></td>
<td><p>Return an independent list of sister nodes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="traversing-browsing-trees">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Traversing (browsing) trees</a><a class="headerlink" href="#traversing-browsing-trees" title="Link to this heading">¶</a></h3>
<p>Often, when processing trees, all nodes need to be visited. This is
called tree traversing. There are different ways to traverse a tree
structure depending on the order in which children nodes are visited.
ETE implements the three most common strategies: <em>preorder</em>,
<em>postorder</em> and <em>levelorder</em>. The following scheme shows the
differences in the strategy for visiting nodes (note that in all cases
the whole tree is browsed):</p>
<ul class="simple">
<li><p><em>preorder</em>: 1) visit the root, 2) traverse the left subtree, 3)
traverse the right subtree.</p></li>
<li><p><em>postorder</em>: 1) traverse the left subtree, 2) traverse the right
subtree, 3) visit the root.</p></li>
<li><p><em>levelorder</em> (default): every node on a level is visited before going
to a lower level.</p></li>
</ul>
<p>Every node in a tree includes a <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.traverse" title="ete4.Tree.traverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">traverse</span></code></a>
method, which can be used to visit, one by one, every node node under
the current partition. In addition, the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.descendants" title="ete4.Tree.descendants"><code class="xref py py-func docutils literal notranslate"><span class="pre">descendants</span></code></a> method can be set to use either a post- or a
preorder strategy. The only difference between <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.traverse" title="ete4.Tree.traverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">traverse</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.descendants" title="ete4.Tree.descendants"><code class="xref py py-func docutils literal notranslate"><span class="pre">descendants</span></code></a> is that
the first will include the root node in the iteration.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.traverse" title="ete4.Tree.traverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.traverse</span></code></a>(self[, strategy, is_leaf_fn])</p></td>
<td><p>Traverse the tree structure under this node and yield the nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.descendants" title="ete4.Tree.descendants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.descendants</span></code></a>(self[, strategy, is_leaf_fn])</p></td>
<td><p>Yield all descendant nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.leaves" title="ete4.Tree.leaves"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.leaves</span></code></a>(self[, is_leaf_fn])</p></td>
<td><p>Yield the terminal nodes (leaves) under this node.</p></td>
</tr>
</tbody>
</table>
<p>The argument <code class="xref py py-attr docutils literal notranslate"><span class="pre">strategy</span></code> can take the values “levelorder”,
“preorder”, or “postorder”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a tree.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Traverse the nodes in postorder.</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s1">&#39;postorder&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># or do some analysis with the node</span>

<span class="c1"># If we want to iterate over a tree excluding the root node, we can</span>
<span class="c1"># use the descendants method instead.</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="s1">&#39;postorder&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># or do some analysis with the node</span>
</pre></div>
</div>
<p>Additionally, you can implement your own traversing function using the
structural attributes of nodes. In the following example, only nodes
between a given leaf and the tree root are visited:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A:1,(B:1,(C:1,D:1):0.5):0.5);&#39;</span><span class="p">)</span>

<span class="c1"># Browse the tree from a specific leaf to the root.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>  <span class="c1"># selects the node named &#39;C&#39;</span>
<span class="k">while</span> <span class="n">node</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># for example, or do some operations with it</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
</pre></div>
</div>
</section>
<section id="advanced-traversing">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Advanced traversing</a><a class="headerlink" href="#advanced-traversing" title="Link to this heading">¶</a></h3>
<section id="collapsing-nodes-while-traversing">
<span id="is-leaf-fn"></span><h4><a class="toc-backref" href="#id14" role="doc-backlink">Collapsing nodes while traversing</a><a class="headerlink" href="#collapsing-nodes-while-traversing" title="Link to this heading">¶</a></h4>
<p>ETE supports the use of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">is_leaf_fn</span></code> argument in most of its
traversing functions. The value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">is_leaf_fn</span></code> is expected to
be a pointer to any python function that accepts a node instance as
its first argument and returns a boolean value (True if node should be
considered a leaf node).</p>
<p>By doing so, all traversing methods will use such a custom function to
decide if a node is a leaf. This becomes specially useful when dynamic
collapsing of nodes is needed, thus avoiding to prune the same tree in
many different ways.</p>
<p>For instance, given a large tree structure, the following code will
export the newick of the pruned version of the topology, where nodes
grouping the same tip labels are collapsed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((((a,a,a)a,a)aa,(b,b)b)ab,(c,(d,d)d)cd);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># show internal names too</span>
<span class="c1">#                  ╭╴a</span>
<span class="c1">#              ╭╴a╶┼╴a</span>
<span class="c1">#         ╭╴aa╶┤   ╰╴a</span>
<span class="c1">#    ╭╴ab╶┤    ╰╴a</span>
<span class="c1"># ╴⊗╶┤    ╰╴b╶┬╴b</span>
<span class="c1">#    │        ╰╴b</span>
<span class="c1">#    ╰╴cd╶┬╴c</span>
<span class="c1">#         ╰╴d╶┬╴d</span>
<span class="c1">#             ╰╴d</span>

<span class="c1"># Cache for every node (for each node, a set of all its leaves&#39; names).</span>
<span class="n">node2labels</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">collapsed_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">node2labels</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">collapsed_leaf</span><span class="p">))</span>
<span class="c1"># ((aa,b)ab,(c,d)cd);</span>

<span class="c1"># We can even load the collapsed version as a new tree.</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">collapsed_leaf</span><span class="p">),</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#    ╭╴ab╶┬╴aa</span>
<span class="c1"># ╴⊗╶┤    ╰╴b</span>
<span class="c1">#    ╰╴cd╶┬╴c</span>
<span class="c1">#         ╰╴d</span>
</pre></div>
</div>
<p>Another interesting use of this approach is to find the first matching
nodes in a given tree that match a custom set of criteria, without
browsing the whole tree structure.</p>
<p>Let’s say we want to get all deepest nodes in a tree whose branch
length is defined and larger than one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,b)ab:2,(c,d)cd:2)abcd:2,((e,f):2,g)efg:2);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># name and distance</span>
<span class="c1">#                 ╭╴ab,2.0╶┬╴a,⊗</span>
<span class="c1">#      ╭╴abcd,2.0╶┤        ╰╴b,⊗</span>
<span class="c1">#      │          ╰╴cd,2.0╶┬╴c,⊗</span>
<span class="c1"># ╴⊗,⊗╶┤                   ╰╴d,⊗</span>
<span class="c1">#      │         ╭╴⊗,2.0╶┬╴e,⊗</span>
<span class="c1">#      ╰╴efg,2.0╶┤       ╰╴f,⊗</span>
<span class="c1">#                ╰╴g,⊗</span>

<span class="k">def</span> <span class="nf">processable_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">leaves</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">processable_node</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># Will print just these two &quot;leaves&quot; (according to processable_node):</span>
<span class="c1">#   abcd</span>
<span class="c1">#   efg</span>
</pre></div>
</div>
</section>
</section>
<section id="iterators-or-lists">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Iterators or lists?</a><a class="headerlink" href="#iterators-or-lists" title="Link to this heading">¶</a></h3>
<p>The methods used to iterate over nodes are <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typesseq">python iterators</a>. The
iterators produce only one element at a time, and thus are normally
faster and take less memory than lists.</p>
<p>Sometimes you will need a list instead, for example if you want to
refer to nodes that have appeared before in the iteration. In that
case, you can create it by adding <code class="docutils literal notranslate"><span class="pre">list(...)</span></code> to your call.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">leaves</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>  <span class="c1"># constructs a list with all the leaves</span>
</pre></div>
</div>
<p>The same is valid for <code class="xref py py-func docutils literal notranslate"><span class="pre">traverse()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">descendants()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">ancestors()</span></code> and so on.</p>
</section>
<section id="finding-nodes-by-their-properties">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Finding nodes by their properties</a><a class="headerlink" href="#finding-nodes-by-their-properties" title="Link to this heading">¶</a></h3>
<p>Both terminal and internal nodes can be located by searching along the
tree structure. Several methods are available:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>t.search_nodes(prop=value)</p></td>
<td><p>Iterator over nodes that have property prop equal to value, as name=’A’</p></td>
</tr>
<tr class="row-odd"><td><p>t.search_descendants(prop=value)</p></td>
<td><p>Same, but only on descendants (excludes the node t itself)</p></td>
</tr>
<tr class="row-even"><td><p>t.search_ancestors(prop=value)</p></td>
<td><p>Iterator over ancestor nodes</p></td>
</tr>
<tr class="row-odd"><td><p>t.search_leaves_by_name(name)</p></td>
<td><p>Iterator over leaf nodes matching a given name</p></td>
</tr>
<tr class="row-even"><td><p>t.common_ancestor([node1, node2, node3])</p></td>
<td><p>Return the first internal node grouping node1, node2 and node3</p></td>
</tr>
<tr class="row-odd"><td><p>t[name]</p></td>
<td><p>Return the first node named name, same as next(t.search_nodes(name=name))</p></td>
</tr>
</tbody>
</table>
<section id="search-all-nodes-matching-a-given-criteria">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Search all nodes matching a given criteria</a><a class="headerlink" href="#search-all-nodes-matching-a-given-criteria" title="Link to this heading">¶</a></h4>
<p>A custom list of nodes matching a given name can be easily obtained
through the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.search_nodes" title="ete4.Tree.search_nodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.search_nodes()</span></code></a> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((H:1,I:1):0.5,A:1,(B:1,(C:1,D:1):0.5):0.5);&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#  ╭─┬╴H</span>
<span class="c1"># ─┤ ╰╴I</span>
<span class="c1">#  ├╴A</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰─┬╴C</span>
<span class="c1">#      ╰╴D</span>

<span class="n">n1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>  <span class="c1"># get node named &#39;D&#39;</span>

<span class="c1"># Get all nodes with distance=0.5</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="s1">&#39;nodes have distance 0.5&#39;</span><span class="p">)</span>

<span class="c1"># We can limit the search to leaves and node names</span>
<span class="n">n2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">search_leaves_by_name</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">))</span>  <span class="c1"># takes the first match</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">)</span>  <span class="c1"># True</span>
</pre></div>
</div>
</section>
<section id="search-nodes-matching-a-given-criteria">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Search nodes matching a given criteria</a><a class="headerlink" href="#search-nodes-matching-a-given-criteria" title="Link to this heading">¶</a></h4>
<p>A limitation of the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.search_nodes" title="ete4.Tree.search_nodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.search_nodes()</span></code></a> method is that you
cannot use complex conditional statements to find specific nodes. When
the search criteria is too complex, you may want to create your own search
function. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_by_size</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Yield nodes with a given number of leaves.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">n</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>

<span class="c1"># Get a list of all nodes containing 6 leaves.</span>
<span class="nb">list</span><span class="p">(</span><span class="n">search_by_size</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="find-the-first-common-ancestor">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Find the first common ancestor</a><a class="headerlink" href="#find-the-first-common-ancestor" title="Link to this heading">¶</a></h4>
<p>Searching for the first common ancestor of a given set of nodes is a
handy way of finding internal nodes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,b)ab,(c,d)cd:2)abcd,((e,f)ef,g)efg)root;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#              ╭╴ab╶┬╴a</span>
<span class="c1">#       ╭╴abcd╶┤    ╰╴b</span>
<span class="c1">#       │      ╰╴cd╶┬╴c</span>
<span class="c1"># ╴root╶┤           ╰╴d</span>
<span class="c1">#       │     ╭╴ef╶┬╴e</span>
<span class="c1">#       ╰╴efg╶┤    ╰╴f</span>
<span class="c1">#             ╰╴g</span>

<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">])</span>  <span class="c1"># will be node abcd</span>
</pre></div>
</div>
</section>
<section id="custom-searching-functions">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Custom searching functions</a><a class="headerlink" href="#custom-searching-functions" title="Link to this heading">¶</a></h4>
<p>A limitation of the previous methods is that you cannot use complex
conditional statements to find specific nodes. However you can use
traversing methods and apply your custom filters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((H:0.3,I:0.1):0.5,A:1,(B:0.4,(C:1,D:1):0.5):0.5):0;&#39;</span><span class="p">)</span>

<span class="c1"># Use a list comprehension, iterating with the traverse() method.</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span> <span class="s1">&#39;nodes have distance &gt; 0.3&#39;</span><span class="p">)</span>

<span class="c1"># Or create a small function to filter your nodes.</span>
<span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span>

<span class="n">matches2</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">),</span> <span class="s1">&#39;nodes have distance &gt; 0.3 and are leaves&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="shortcuts">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Shortcuts</a><a class="headerlink" href="#shortcuts" title="Link to this heading">¶</a></h4>
<p>Finally, ETE implements a built-in method to find the first node
matching a given name, which is one of the most common tasks needed
for tree analysis. This can be done through the operator <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Thus,
<code class="docutils literal notranslate"><span class="pre">t['A']</span></code> will return the first node whose name is “A” and that is
under the tree <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((H,I),A,(B,(C,(J,(F,D)))));&#39;</span><span class="p">)</span>

<span class="c1"># Get the node D in a simple way.</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>

<span class="c1"># Get the path from D to the root (similar to list(t.ancestors())).</span>
<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">D</span>
<span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;There are&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nodes between D and the root.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="checking-the-monophyly-of-properties-within-a-tree">
<span id="check-monophyly"></span><h2><a class="toc-backref" href="#id22" role="doc-backlink">Checking the monophyly of properties within a tree</a><a class="headerlink" href="#checking-the-monophyly-of-properties-within-a-tree" title="Link to this heading">¶</a></h2>
<p>Although monophyly is actually a phylogenetic concept used to refer to
a set of species that group exclusively together within a tree
partition, the idea can be easily used for any type of trees.</p>
<p>Therefore, we could consider that a set of values for a given node
property present in our tree is monophyletic, if such values group
exclusively together as a single tree partition. If not, the
corresponding relationship connecting such values (para- or
poly-phyletic) could be also be inferred.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.check_monophyly" title="ete4.Tree.check_monophyly"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.check_monophyly()</span></code></a> method will do so when a given tree
is queried for any custom attribute.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((((((a,e),i),o),h),u),((f,g),j));&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#          ╭─┬╴a</span>
<span class="c1">#        ╭─┤ ╰╴e</span>
<span class="c1">#      ╭─┤ ╰╴i</span>
<span class="c1">#    ╭─┤ ╰╴o</span>
<span class="c1">#  ╭─┤ ╰╴h</span>
<span class="c1"># ─┤ ╰╴u</span>
<span class="c1">#  │ ╭─┬╴f</span>
<span class="c1">#  ╰─┤ ╰╴g</span>
<span class="c1">#    ╰╴j</span>

<span class="c1"># We can check how, indeed, all vowels are not monophyletic in the previous</span>
<span class="c1"># tree, but paraphyletic (monophyletic except for a group that is monophyletic):</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="c1"># False (not monophyletic), &#39;paraphyletic&#39; (type of group), {h} (the leaves not included)</span>

<span class="c1"># However, the following set of vowels are monophyletic:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="c1"># True (it is monophyletic), &#39;monophyletic&#39; (type of group), set() (no leaves left)</span>

<span class="c1"># When a group is not monophyletic nor paraphyletic, it is called polyphyletic.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="c1"># False, &#39;polyphyletic&#39;, {e, a, o}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the property is set to “species” in a <a class="reference internal" href="../reference/reference_phylo.html#ete4.PhyloTree" title="ete4.PhyloTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">PhyloTree</span></code></a> node,
this method will correspond to the standard phylogenetic definition
of monophyletic, paraphyletic, and polyphyletic.</p>
</div>
<p>Finally, the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_monophyletic" title="ete4.Tree.get_monophyletic"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_monophyletic()</span></code></a> method is also provided,
which returns a list of nodes within a tree where a given set of
properties are monophyletic. Note that, although a set of values are
not monophyletic regarding the whole tree, several independent
monophyletic partitions could be found within the same topology.</p>
<p>In the following example we get all clusters within the same tree
exclusively grouping a custom set of annotations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s2">&quot;((((((a,e),i),o),h),u),((f,g),(j,k)));&quot;</span><span class="p">)</span>

<span class="c1"># Annotate the tree using external data.</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
          <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span><span class="s1">&#39;purple&#39;</span><span class="p">,</span>
          <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
          <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="s1">&#39;yellow&#39;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">leaf</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">show_internal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#          ╭─┬╴a,green</span>
<span class="c1">#        ╭─┤ ╰╴e,green</span>
<span class="c1">#      ╭─┤ ╰╴i,yellow</span>
<span class="c1">#    ╭─┤ ╰╴o,black</span>
<span class="c1">#  ╭─┤ ╰╴h,none</span>
<span class="c1"># ─┤ ╰╴u,purple</span>
<span class="c1">#  │ ╭─┬╴f,yellow</span>
<span class="c1">#  ╰─┤ ╰╴g,green</span>
<span class="c1">#    ╰─┬╴j,yellow</span>
<span class="c1">#      ╰╴k,yellow</span>

<span class="c1"># Obtain clusters exclusively green and yellow.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Green-yellow clusters:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">get_monophyletic</span><span class="p">(</span><span class="n">prop</span><span class="o">=</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">show_internal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># Green-yellow clusters:</span>
<span class="c1">#</span>
<span class="c1">#  ╭─┬╴a,green</span>
<span class="c1"># ─┤ ╰╴e,green</span>
<span class="c1">#  ╰╴i,yellow</span>
<span class="c1">#</span>
<span class="c1">#  ╭─┬╴f,yellow</span>
<span class="c1"># ─┤ ╰╴g,green</span>
<span class="c1">#  ╰─┬╴j,yellow</span>
<span class="c1">#    ╰╴k,yellow</span>
</pre></div>
</div>
</section>
<section id="caching-tree-content-for-faster-lookup-operations">
<span id="cache-node-content"></span><h2><a class="toc-backref" href="#id23" role="doc-backlink">Caching tree content for faster lookup operations</a><a class="headerlink" href="#caching-tree-content-for-faster-lookup-operations" title="Link to this heading">¶</a></h2>
<p>If your program needs to access to the content of different nodes very
frequently, traversing the tree to get the leaves of each node over
and over will produce significant slowdowns in your algorithm.</p>
<p>ETE provides a convenient methods to cache frequently used data. The
method <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_cached_content" title="ete4.Tree.get_cached_content"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_cached_content()</span></code></a> returns a dictionary in which
keys are node instances and values represent the content of such
nodes. By default, “content” is understood as a set of leaf nodes.
After you retrieve this cached data, looking up the size or tip names
under a given node will be instantaneous.</p>
<p>Instead of caching the nodes themselves, specific properties can be
cached by setting a custom <code class="xref py py-attr docutils literal notranslate"><span class="pre">prop</span></code> value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

<span class="n">node2leaves</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>

<span class="c1"># Print the size of each node, without the need of traversing the subtrees every time.</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Node </span><span class="si">%s</span><span class="s1"> contains </span><span class="si">%d</span><span class="s1"> tips.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node2leaves</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span>
</pre></div>
</div>
</section>
<section id="node-annotation">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Node annotation</a><a class="headerlink" href="#node-annotation" title="Link to this heading">¶</a></h2>
<p>Adding properties to the nodes of a tree is called tree annotation.
ETE stores the properties (annotations) of a node in a dictionary
called <code class="docutils literal notranslate"><span class="pre">props</span></code>.</p>
<p>In a phylogenetic tree, the nodes (with their branches) often have
names, branch lengths, and branch supports. ETE provides a shortcut
for their corresponding properties <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">dist</span></code>, and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">support</span></code>, so instead of writing <code class="docutils literal notranslate"><span class="pre">n.props.get('name')</span></code>, you
can write <code class="docutils literal notranslate"><span class="pre">n.name</span></code>, and similarly for <code class="docutils literal notranslate"><span class="pre">n.dist</span></code> and <code class="docutils literal notranslate"><span class="pre">n.support</span></code>.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.add_prop" title="ete4.Tree.add_prop"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.add_prop()</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.add_props" title="ete4.Tree.add_props"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.add_props()</span></code></a> methods allow to
add extra properties (features, annotations) to any node. The first
one allows to add one one feature at a time, while the second one can
be used to add many features with the same call.</p>
<p>Similarly, <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.del_prop" title="ete4.Tree.del_prop"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.del_prop()</span></code></a> can be used to delete a property.</p>
<p>Example using annotations when working on a tree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((H:0.3,I:0.1),A:1,(B:0.4,(C:0.5,(J:1.3,(F:1.2,D:0.1)))));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
<span class="c1">#      ╭╴name=H,dist=0.3</span>
<span class="c1">#   ╭──┤</span>
<span class="c1">#   │  ╰╴name=I,dist=0.1</span>
<span class="c1">#   │</span>
<span class="c1"># ──┼╴name=A,dist=1.0</span>
<span class="c1">#   │</span>
<span class="c1">#   │  ╭╴name=B,dist=0.4</span>
<span class="c1">#   ╰──┤</span>
<span class="c1">#      │  ╭╴name=C,dist=0.5</span>
<span class="c1">#      ╰──┤</span>
<span class="c1">#         │  ╭╴name=J,dist=1.3</span>
<span class="c1">#         ╰──┤</span>
<span class="c1">#            │  ╭╴name=F,dist=1.2</span>
<span class="c1">#            ╰──┤</span>
<span class="c1">#               ╰╴name=D,dist=0.1</span>

<span class="c1"># Reference some nodes (to use later).</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>  <span class="c1"># by name</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span>
<span class="n">ancestor_JFC</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>  <span class="c1"># by common ancestor</span>

<span class="c1"># Let&#39;s now add some custom features to our nodes.</span>
<span class="n">C</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">nodetype</span><span class="o">=</span><span class="s1">&#39;internal&#39;</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">ancestor_JFC</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Properties of </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">props</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Let&#39;s annotate by looping over all nodes.</span>
<span class="c1"># (Note that this overwrites the previous values.)</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">is_vowel</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s1">&#39;AEIOU&#39;</span>
    <span class="n">leaf</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="n">is_vowel</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Now we use this information to analyze the tree.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This tree has&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="s1">&#39;vowel nodes&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;They are:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;vowel&#39;</span><span class="p">]])</span>

<span class="c1"># But features may refer to any kind of data, not only simple values.</span>
<span class="c1"># For example, we can calculate some values and store them within nodes.</span>
<span class="c1">#</span>
<span class="c1"># Let&#39;s detect leaves under &#39;ancestor_JFC&#39; with distance higher than 1.</span>
<span class="c1"># Note that it traverses a subtree which starts from &#39;ancestor_JFC&#39;.</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">]</span>

<span class="c1"># And save this pre-computed information into the ancestor node.</span>
<span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">long_branch_nodes</span><span class="o">=</span><span class="n">matches</span><span class="p">)</span>

<span class="c1"># Prints the precomputed nodes</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;These are the leaves under ancestor_JFC with long branches:&#39;</span><span class="p">,</span>
      <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;long_branch_nodes&#39;</span><span class="p">]])</span>

<span class="c1"># We can also use the add_props() method to dynamically add new features.</span>
<span class="n">value</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Custom label value: &#39;</span><span class="p">)</span>
<span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Ancestor has now the &quot;label&quot; property with value &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot;:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ancestor_JFC</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
</pre></div>
</div>
<p>The original newick format did not support adding extra features to a
tree. ETE includes support for the <a class="reference external" href="http://phylosoft.org/NHX">New Hampshire eXtended format</a> (NHX), which uses the original newick
standard and adds the possibility of saving additional data related to
each tree node.</p>
<p>Here is an example of a extended newick representation in which extra
information is added to an internal node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="mf">0.3</span><span class="p">,(</span><span class="n">B</span><span class="p">:</span><span class="mf">0.7</span><span class="p">,(</span><span class="n">D</span><span class="p">:</span><span class="mf">0.6</span><span class="p">,</span><span class="n">G</span><span class="p">:</span><span class="mf">0.1</span><span class="p">):</span><span class="mf">0.6</span><span class="p">[</span><span class="o">&amp;&amp;</span><span class="n">NHX</span><span class="p">:</span><span class="n">conf</span><span class="o">=</span><span class="mf">0.1</span><span class="p">:</span><span class="n">name</span><span class="o">=</span><span class="n">internal</span><span class="p">]):</span><span class="mf">0.5</span><span class="p">);</span>
</pre></div>
</div>
<p>As you can see, extra node features in the NHX format are enclosed
between brackets. ETE is able to read and write features using this
format, however, the encoded information is expected to be exportable
as plain text.</p>
<p>The NHX format is automatically detected when reading a newick file,
and the detected node properties are added. You can access the
information by using <code class="docutils literal notranslate"><span class="pre">node.props[prop_name]</span></code>.</p>
<p>Similarly, properties added to a tree can be included within the
normal newick representation using the NHX notation. For this, you can
call the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.write" title="ete4.Tree.write"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.write()</span></code></a> method using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">props</span></code> argument,
which is expected to be a list with the feature names that you want to
include in the newick string. Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">props=None</span></code>) to include all
the node’s data into the newick string.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((H:0.3,I:0.1),A:1,(B:0.4,(C:0.5,(J:1.3,(F:1.2,D:0.1)))));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#  ╭─┬╴H</span>
<span class="c1"># ─┤ ╰╴I</span>
<span class="c1">#  ├╴A</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰─┬╴C</span>
<span class="c1">#      ╰─┬╴J</span>
<span class="c1">#        ╰─┬╴F</span>
<span class="c1">#          ╰╴D</span>

<span class="c1"># Add some more properties to leaves:</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">is_vowel</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s1">&#39;AEIOU&#39;</span>
    <span class="n">leaf</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="n">is_vowel</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NHX notation including vowel and confidence properties:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vowel&#39;</span><span class="p">]))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NHX notation including all data in the nodes:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
<p>To read NHX notation you can just read it as a normal newick:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the NHX example from https://www.phylosoft.org/NHX/</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">(((ADH2:0.1[&amp;&amp;NHX:S=human:E=1.1.1.1], ADH1:0.11[&amp;&amp;NHX:S=human:E=1.1.1.1]):0.05</span>
<span class="s2">[&amp;&amp;NHX:S=Primates:E=1.1.1.1:D=Y:B=100], ADHY:0.1[&amp;&amp;NHX:S=nematode:</span>
<span class="s2">E=1.1.1.1],ADHX:0.12[&amp;&amp;NHX:S=insect:E=1.1.1.1]):0.1[&amp;&amp;NHX:S=Metazoa:</span>
<span class="s2">E=1.1.1.1:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH3:0.13[&amp;&amp;NHX:S=yeast:</span>
<span class="s2">E=1.1.1.1], ADH2:0.12[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH1:0.11[&amp;&amp;NHX:S=yeast:E=1.1.1.1]):0.1</span>
<span class="s2">[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:E=1.1.1.1:D=N];</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#                  ╭╴⊗,Primates╶┬╴ADH2,human</span>
<span class="c1">#      ╭╴⊗,Metazoa╶┤            ╰╴ADH1,human</span>
<span class="c1">#      │           ├╴ADHY,nematode</span>
<span class="c1"># ╴⊗,⊗╶┤           ╰╴ADHX,insect</span>
<span class="c1">#      │         ╭╴ADH4,yeast</span>
<span class="c1">#      ╰╴⊗,Fungi╶┼╴ADH3,yeast</span>
<span class="c1">#                ├╴ADH2,yeast</span>
<span class="c1">#                ╰╴ADH1,yeast</span>

<span class="c1"># And access the node&#39;s properties.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S property for the nodes that have it:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;S&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">props</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]))</span>
<span class="c1"># S property for the nodes that have it:</span>
<span class="c1">#   [0]: Metazoa</span>
<span class="c1">#   [1]: Fungi</span>
<span class="c1">#   [0, 0]: Primates</span>
<span class="c1">#   ADHY: nematode</span>
<span class="c1">#   ADHX: insect</span>
<span class="c1">#   ADH4: yeast</span>
<span class="c1">#   ADH3: yeast</span>
<span class="c1">#   ADH2: yeast</span>
<span class="c1">#   ADH1: yeast</span>
<span class="c1">#   ADH2: human</span>
<span class="c1">#   ADH1: human</span>
</pre></div>
</div>
</section>
<section id="comparing-trees">
<span id="robinson-foulds"></span><h2><a class="toc-backref" href="#id25" role="doc-backlink">Comparing trees</a><a class="headerlink" href="#comparing-trees" title="Link to this heading">¶</a></h2>
<section id="distances-between-trees">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Distances between trees</a><a class="headerlink" href="#distances-between-trees" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.compare" title="ete4.Tree.compare"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.compare()</span></code></a> function allows to calculate distances
between two trees based on any node property (i.e. name, species,
other tags) using Robinson-Foulds and edge compatibility distances. It
automatically handles differences in tree sizes, shared nodes and
duplicated feature names.</p>
<p>Its result is a dictionary with the following contents:</p>
<ul class="simple">
<li><p>result[‘rf’] = Robinson-Foulds distance between the two trees.
(Average of Robinson-Foulds distances if target tree contained
duplication and was split in several subtrees.)</p></li>
<li><p>result[‘max_rf’] = Maximum Robinson-Foulds distance expected for this comparison.</p></li>
<li><p>result[‘norm_rf’] = Normalized Robinson-Foulds distance (from 0 to 1).</p></li>
<li><p>result[‘effective_tree_size’] = Size of the compared trees, which
are pruned to the common shared nodes.</p></li>
<li><p>result[‘ref_edges_in_source’] = Compatibility score of the target
tree with respect to the source tree (how many edges in reference
are found in the source).</p></li>
<li><p>result[‘source_edges_in_ref’] = Compatibility score of the source
tree with respect to the reference tree (how many edges in source
are found in the reference).</p></li>
<li><p>result[‘source_subtrees’] = Number of subtrees in the source tree (1
if it does not contain duplications).</p></li>
<li><p>result[‘common_edges’] = Set of common edges between source tree and
reference.</p></li>
<li><p>result[‘source_edges’] = Set of edges found in the source tree.</p></li>
<li><p>result[‘ref_edges’] = Set of edges found in the reference tree.</p></li>
<li><p>result[‘treeko_dist’] = TreeKO speciation distance for comparisons
including duplication nodes.</p></li>
</ul>
</section>
<section id="robinson-foulds-distance">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Robinson-Foulds distance</a><a class="headerlink" href="#robinson-foulds-distance" title="Link to this heading">¶</a></h3>
<p>Two tree topologies can be compared using the Robinson-Foulds (RF)
metric. The method <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.robinson_foulds" title="ete4.Tree.robinson_foulds"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.robinson_foulds()</span></code></a> available for any ETE
tree node allows to:</p>
<ul class="simple">
<li><p>Compare two tree topologies by their name labels (default) or any
other annotated feature in the tree.</p></li>
<li><p>Compare topologies of different size and content. When two trees
contain a different set of labels, only shared leaves will be used.</p></li>
<li><p>Examine size and content of matching and missing partitions. Since
the method returns the list of partitions found in both trees,
details about matching partitions can be obtained easily.</p></li>
<li><p>Discard edges from the comparison based on their support value.</p></li>
<li><p>Automatically expand polytomies (multifurcations) in source and
target trees.</p></li>
</ul>
<p>There is also a command line tool providing most used features:
<code class="docutils literal notranslate"><span class="pre">ete</span> <span class="pre">compare</span></code>.</p>
<p>The following example shows several of the above mentioned features:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,b),c),((e,f),g));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,c),b),((e,f),g));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="c1">#    ╭─┬╴a</span>
<span class="c1">#  ╭─┤ ╰╴b</span>
<span class="c1"># ─┤ ╰╴c</span>
<span class="c1">#  │ ╭─┬╴e</span>
<span class="c1">#  ╰─┤ ╰╴f</span>
<span class="c1">#    ╰╴g</span>
<span class="c1">#    ╭─┬╴a</span>
<span class="c1">#  ╭─┤ ╰╴c</span>
<span class="c1"># ─┤ ╰╴b</span>
<span class="c1">#  │ ╭─┬╴e</span>
<span class="c1">#  ╰─┤ ╰╴f</span>
<span class="c1">#    ╰╴g</span>

<span class="n">rf</span><span class="p">,</span> <span class="n">rf_max</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span> <span class="n">parts_t1</span><span class="p">,</span> <span class="n">parts_t2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;RF distance is </span><span class="si">{</span><span class="n">rf</span><span class="si">}</span><span class="s1"> over a total of </span><span class="si">{</span><span class="n">rf_max</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Partitions in tree2 that were not found in tree1:&#39;</span><span class="p">,</span> <span class="n">parts_t1</span> <span class="o">-</span> <span class="n">parts_t2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Partitions in tree1 that were not found in tree2:&#39;</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">-</span> <span class="n">parts_t1</span><span class="p">)</span>
<span class="c1"># RF distance is 2 over a total of 8</span>
<span class="c1"># Partitions in tree2 that were not found in tree1: {(&#39;a&#39;, &#39;b&#39;)}</span>
<span class="c1"># Partitions in tree1 that were not found in tree2: {(&#39;a&#39;, &#39;c&#39;)}</span>
</pre></div>
</div>
<p>We can also compare trees sharing only part of their labels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,b),c),((e,f),g));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,c),b),(g,H));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="c1">#    ╭─┬╴a</span>
<span class="c1">#  ╭─┤ ╰╴b</span>
<span class="c1"># ─┤ ╰╴c</span>
<span class="c1">#  │ ╭─┬╴e</span>
<span class="c1">#  ╰─┤ ╰╴f</span>
<span class="c1">#    ╰╴g</span>
<span class="c1">#    ╭─┬╴a</span>
<span class="c1">#  ╭─┤ ╰╴c</span>
<span class="c1"># ─┤ ╰╴b</span>
<span class="c1">#  ╰─┬╴g</span>
<span class="c1">#    ╰╴H</span>

<span class="n">rf</span><span class="p">,</span> <span class="n">rf_max</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span> <span class="n">parts_t1</span><span class="p">,</span> <span class="n">parts_t2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># Same distance holds even for partially overlapping trees.</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;RF distance is </span><span class="si">{</span><span class="n">rf</span><span class="si">}</span><span class="s1"> over a total of </span><span class="si">{</span><span class="n">rf_max</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Partitions in tree2 that were not found in tree1:&#39;</span><span class="p">,</span> <span class="n">parts_t1</span> <span class="o">-</span> <span class="n">parts_t2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Partitions in tree1 that were not found in tree2:&#39;</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">-</span> <span class="n">parts_t1</span><span class="p">)</span>
<span class="c1"># RF distance is 2 over a total of 4</span>
<span class="c1"># Partitions in tree2 that were not found in tree1: {(&#39;a&#39;, &#39;b&#39;)}</span>
<span class="c1"># Partitions in tree1 that were not found in tree2: {(&#39;a&#39;, &#39;c&#39;)}</span>
</pre></div>
</div>
</section>
</section>
<section id="modifying-tree-topology">
<span id="sec-modifying-tree-topology"></span><h2><a class="toc-backref" href="#id28" role="doc-backlink">Modifying tree topology</a><a class="headerlink" href="#modifying-tree-topology" title="Link to this heading">¶</a></h2>
<section id="creating-trees-from-scratch">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Creating trees from scratch</a><a class="headerlink" href="#creating-trees-from-scratch" title="Link to this heading">¶</a></h3>
<p>If no arguments are passed to the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree" title="ete4.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a> class constructor,
an empty tree node will be returned. Such an orphan node can be used
to populate a tree from scratch. For this, the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.up" title="ete4.Tree.up"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Tree.up</span></code></a>,
and <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.children" title="ete4.Tree.children"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Tree.children</span></code></a> attributes should never be used (unless
it is strictly necessary). Instead, several methods exist to
manipulate the topology of a tree:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.populate" title="ete4.Tree.populate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.populate</span></code></a>(self, size[, names, model, ...])</p></td>
<td><p>Populate current node with a dichotomic random topology.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.add_child" title="ete4.Tree.add_child"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.add_child</span></code></a>(self[, child, name, dist, ...])</p></td>
<td><p>Add a new child to this node and return it.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.add_sister" title="ete4.Tree.add_sister"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.add_sister</span></code></a>(self[, sister, name, dist])</p></td>
<td><p>Add a sister to this node and return it.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.delete" title="ete4.Tree.delete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.delete</span></code></a>(self[, prevent_nondicotomic, ...])</p></td>
<td><p>Delete node from the tree structure, keeping its children.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.detach" title="ete4.Tree.detach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree.detach</span></code></a>(self)</p></td>
<td><p>Detach this node (and descendants) from its parent and return itself.</p></td>
</tr>
</tbody>
</table>
<p>As an example of how to use them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>  <span class="c1"># create an empty tree</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>  <span class="c1"># add new child to the tree root and return it</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># add new child to one of the branches</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">add_sister</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>  <span class="c1"># add a second child to same branch as before</span>
<span class="c1"># Note that the last one did it by using a sister as the starting point.</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>  <span class="c1"># add a third child (multifurcations are ok)</span>

<span class="c1"># Add 6 random leaves to the R branch, with names &#39;r1&#39; to &#39;r6&#39;.</span>
<span class="n">R</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">names_library</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r1&#39;</span><span class="p">,</span> <span class="s1">&#39;r2&#39;</span><span class="p">,</span> <span class="s1">&#39;r3&#39;</span><span class="p">,</span> <span class="s1">&#39;r4&#39;</span><span class="p">,</span> <span class="s1">&#39;r5&#39;</span><span class="p">,</span> <span class="s1">&#39;r6&#39;</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#    ╭╴C</span>
<span class="c1">#  ╭─┼╴D</span>
<span class="c1">#  │ ╰─┬╴r6</span>
<span class="c1">#  │   ╰─┬╴r5</span>
<span class="c1"># ─┤     ╰─┬╴r4</span>
<span class="c1">#  │       ╰─┬╴r3</span>
<span class="c1">#  │         ╰─┬╴r2</span>
<span class="c1">#  │           ╰╴r1</span>
<span class="c1">#  ╰╴B</span>
</pre></div>
</div>
<p>A common use of the <code class="xref py py-func docutils literal notranslate"><span class="pre">populate()</span></code> method is to quickly create
example trees from scratch. Here we create a random tree with 100
leaves:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="how-to-delete-eliminate-or-remove-detach-nodes">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">How to delete/eliminate or remove/detach nodes</a><a class="headerlink" href="#how-to-delete-eliminate-or-remove-detach-nodes" title="Link to this heading">¶</a></h3>
<p>In ETE there is a difference between detaching and deleting a node.</p>
<p>Detaching disconnects a complete partition from the tree structure, so
all its descendants are also disconnected from the tree. There are two
methods to perform this action: <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.remove_child" title="ete4.Tree.remove_child"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.remove_child()</span></code></a> and
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.detach" title="ete4.Tree.detach"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.detach()</span></code></a>.</p>
<p>In contrast, deleting a node means eliminating such node without
affecting its descendants. Children from the deleted node are
automatically connected to the next possible parent.</p>
<p>This is better understood with the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#            ╭╴D╶┬╴H</span>
<span class="c1">#        ╭╴B╶┤   ╰╴K</span>
<span class="c1">#    ╭╴A╶┤   ╰╴G╶┬╴F</span>
<span class="c1">#    │   │       ╰╴I</span>
<span class="c1"># ╴⊗╶┤   ╰╴E</span>
<span class="c1">#    │   ╭╴J╶┬╴L</span>
<span class="c1">#    ╰╴C╶┤   ╰╴O╶┬╴N</span>
<span class="c1">#        │       ╰╴Q</span>
<span class="c1">#        ╰╴M╶┬╴P</span>
<span class="c1">#            ╰╴S</span>

<span class="c1"># Get specific nodes.</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>

<span class="c1"># If we REMOVE the node J from the tree, the whole partition under J will</span>
<span class="c1"># be detached from the tree and it will be considered an independent tree.</span>
<span class="c1"># We can do the same with either J.detach() or C.remove_child(J).</span>
<span class="n">removed_node</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># same as C.remove_child(J)</span>

<span class="c1"># Tree after REMOVING the node J:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#            ╭╴D╶┬╴H</span>
<span class="c1">#        ╭╴B╶┤   ╰╴K</span>
<span class="c1">#    ╭╴A╶┤   ╰╴G╶┬╴F</span>
<span class="c1"># ╴⊗╶┤   │       ╰╴I</span>
<span class="c1">#    │   ╰╴E</span>
<span class="c1">#    ╰╴C╶╌╴M╶┬╴P</span>
<span class="c1">#            ╰╴S</span>

<span class="c1"># However, if we DELETE the node G, only G will be eliminated from the</span>
<span class="c1"># tree, and all its descendants will then hang from the next upper node.</span>
<span class="n">G</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

<span class="c1"># Tree after DELETING the node G:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#            ╭╴D╶┬╴H</span>
<span class="c1">#        ╭╴B╶┤   ╰╴K</span>
<span class="c1">#    ╭╴A╶┤   ├╴F</span>
<span class="c1"># ╴⊗╶┤   │   ╰╴I</span>
<span class="c1">#    │   ╰╴E</span>
<span class="c1">#    ╰╴C╶╌╴M╶┬╴P</span>
<span class="c1">#            ╰╴S</span>
</pre></div>
</div>
</section>
</section>
<section id="pruning-trees">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">Pruning trees</a><a class="headerlink" href="#pruning-trees" title="Link to this heading">¶</a></h2>
<p>Pruning a tree means to obtain the topology that connects a certain
group of items by removing the unnecessary edges. To facilitate this
task, ETE implements the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.prune" title="ete4.Tree.prune"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.prune()</span></code></a> method, which can be used
by providing the list of terminal and/or internal nodes that must be
kept in the tree.</p>
<p>The <cite>preserve_branch_length</cite> flag allows to remove nodes from a tree
while keeping original distances among remaining nodes.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((((H,K),(F,I)G),E),((L,(N,Q)O),(P,S)));&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#      ╭─┬╴H</span>
<span class="c1">#    ╭─┤ ╰╴K</span>
<span class="c1">#  ╭─┤ ╰─┬╴F</span>
<span class="c1">#  │ │   ╰╴I</span>
<span class="c1"># ─┤ ╰╴E</span>
<span class="c1">#  │ ╭─┬╴L</span>
<span class="c1">#  ╰─┤ ╰─┬╴N</span>
<span class="c1">#    │   ╰╴Q</span>
<span class="c1">#    ╰─┬╴P</span>
<span class="c1">#      ╰╴S</span>

<span class="c1"># Prune the tree in order to keep only some leaf nodes.</span>
<span class="n">t</span><span class="o">.</span><span class="n">prune</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">])</span>

<span class="c1"># Pruned tree:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#    ╭─┬╴H</span>
<span class="c1">#  ╭─┤ ╰╴F</span>
<span class="c1"># ─┤ ╰╴E</span>
<span class="c1">#  ╰─┬╴Q</span>
<span class="c1">#    ╰╴P</span>
</pre></div>
</div>
<p>In the next section we will see how to re-create the same tree again.</p>
</section>
<section id="concatenating-trees">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">Concatenating trees</a><a class="headerlink" href="#concatenating-trees" title="Link to this heading">¶</a></h2>
<p>Given that all tree nodes share the same basic properties, they can be
connected freely. In fact, any node can add a whole subtree as a
child, so we can actually <em>cut &amp; paste</em> partitions.</p>
<p>To do so, you can call the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.add_child" title="ete4.Tree.add_child"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.add_child()</span></code></a> method using another tree
node as first argument. If such a node is the root node of a
different tree, you will concatenate the two tree structures.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind of operation may result in circular tree structures if you
add a node’s ancestor as one of its descendants. ETE performs some
basic checks, but a full check would affect seriously the
performance. For this reason, users themselves should take care not
to create circular structures by mistake.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A,(B,C));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((D,E),(F,G));&#39;</span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(H,((I,J),(K,L)));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
<span class="c1"># ─┬╴A</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰╴C</span>
<span class="c1">#  ╭─┬╴D</span>
<span class="c1"># ─┤ ╰╴E</span>
<span class="c1">#  ╰─┬╴F</span>
<span class="c1">#    ╰╴G</span>
<span class="c1">#  ╭╴H</span>
<span class="c1"># ─┤ ╭─┬╴I</span>
<span class="c1">#  ╰─┤ ╰╴J</span>
<span class="c1">#    ╰─┬╴K</span>
<span class="c1">#      ╰╴L</span>

<span class="c1"># Add two other trees as children of node A.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t1</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>

<span class="c1"># Resulting concatenated tree:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="c1">#      ╭─┬╴D</span>
<span class="c1">#    ╭─┤ ╰╴E</span>
<span class="c1">#    │ ╰─┬╴F</span>
<span class="c1">#  ╭─┤   ╰╴G</span>
<span class="c1">#  │ │ ╭╴H</span>
<span class="c1">#  │ ╰─┤ ╭─┬╴I</span>
<span class="c1"># ─┤   ╰─┤ ╰╴J</span>
<span class="c1">#  │     ╰─┬╴K</span>
<span class="c1">#  │       ╰╴L</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰╴C</span>
</pre></div>
</div>
</section>
<section id="copying-duplicating-trees">
<span id="copying-trees"></span><span id="sec-tree-rooting"></span><h2><a class="toc-backref" href="#id33" role="doc-backlink">Copying (duplicating) trees</a><a class="headerlink" href="#copying-duplicating-trees" title="Link to this heading">¶</a></h2>
<p>ETE provides several strategies to clone tree structures. The method
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.copy" title="ete4.Tree.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.copy()</span></code></a> can be used to produce a new independent tree
object with the exact same topology and features as the original.
However, as trees may involve many intricate levels of branches and
nested features, 4 different methods are available to create a tree
copy:</p>
<blockquote>
<div><ul class="simple">
<li><p>“newick”: Tree topology, node names, branch lengths and branch
support values will be copied as represented in the newick string
This method is based on newick format serialization works very fast
even for large trees.</p></li>
<li><p>“newick-extended”: Tree topology and all node features will be
copied based on the extended newick format representation. Only
node features will be copied, thus excluding other node
attributes. As this method is also based on newick serialisation,
features will be converted into text strings when making the
copy. Performance will depend on the tree size and the number and
type of features being copied.</p></li>
<li><p>“cpickle”: This is the default method. The whole node structure and
its content will be cloned based on the cPickle object
serialization python approach.  This method is slower, but
recommended for full tree copying.</p></li>
<li><p>“deepcopy”: The whole node structure and its content is copied
based on the standard “copy” Python functionality. This is the
slowest method, but it allows to copy very complex objects even
when attributes point to lambda functions.</p></li>
</ul>
</div></blockquote>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;((A,B)Internal_1:0.7,(C,D)Internal_2:0.5)root:1.3;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add a custom annotation to the node named A.</span>
<span class="n">t</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;custom value&#39;</span><span class="p">)</span>

<span class="c1"># Add a complex feature to the A node, consisting of a list of lists.</span>
<span class="n">t</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add_props</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
<span class="c1">#                                                ╭╴name=A,label=custom value,complex=[[0, 1], [2, 3]]</span>
<span class="c1">#                     ╭╴name=Internal_1,dist=0.7╶┤</span>
<span class="c1">#                     │                          ╰╴name=B</span>
<span class="c1"># ╴name=root,dist=1.3╶┤</span>
<span class="c1">#                     │                          ╭╴name=C</span>
<span class="c1">#                     ╰╴name=Internal_2,dist=0.5╶┤</span>
<span class="c1">#                                                ╰╴name=D</span>

<span class="c1"># Newick copy will lose custom node annotations, complex features,</span>
<span class="c1"># but not names and branch values.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;newick&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
<span class="c1">#                                                ╭╴name=A</span>
<span class="c1">#                     ╭╴name=Internal_1,dist=0.7╶┤</span>
<span class="c1">#                     │                          ╰╴name=B</span>
<span class="c1"># ╴name=root,dist=1.3╶┤</span>
<span class="c1">#                     │                          ╭╴name=C</span>
<span class="c1">#                     ╰╴name=Internal_2,dist=0.5╶┤</span>
<span class="c1">#                                                ╰╴name=D</span>

<span class="c1"># Extended newick copy will transfer custom annotations as text</span>
<span class="c1"># strings, so complex features are lost.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;newick-extended&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
<span class="c1">#                              ╭╴name=A,complex=_0_ 1_|_2_ 3_,label=custom value</span>
<span class="c1">#   ╭╴name=Internal_1,dist=0.7╶┤</span>
<span class="c1">#   │                          ╰╴name=B</span>
<span class="c1"># ──┤</span>
<span class="c1">#   │                          ╭╴name=C</span>
<span class="c1">#   ╰╴name=Internal_2,dist=0.5╶┤</span>
<span class="c1">#                              ╰╴name=D</span>

<span class="c1"># The default pickle method will produce an exact clone of the</span>
<span class="c1"># original tree, where features are duplicated keeping their</span>
<span class="c1"># python data type.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
<span class="c1">#                                                ╭╴name=A,label=custom value,complex=[[0, 1], [2, 3]]</span>
<span class="c1">#                     ╭╴name=Internal_1,dist=0.7╶┤</span>
<span class="c1">#                     │                          ╰╴name=B</span>
<span class="c1"># ╴name=root,dist=1.3╶┤</span>
<span class="c1">#                     │                          ╭╴name=C</span>
<span class="c1">#                     ╰╴name=Internal_2,dist=0.5╶┤</span>
<span class="c1">#                                                ╰╴name=D</span>
</pre></div>
</div>
</section>
<section id="solving-multifurcations">
<span id="resolve-polytomy"></span><h2><a class="toc-backref" href="#id34" role="doc-backlink">Solving multifurcations</a><a class="headerlink" href="#solving-multifurcations" title="Link to this heading">¶</a></h2>
<p>When a tree contains a polytomy (a node with more than 2 children),
the method <code class="xref py py-func docutils literal notranslate"><span class="pre">resolve_polytomy()</span></code> can be used to convert the node
into an arbitrarily bifurcated structure. This is really not a solution
for the polytomy but it allows to export the tree as a strictly
bifurcated newick structure, which is a requirement for some external
software.</p>
<p>The method can be used on a very specific node while keeping the rest
of the tree intact by disabling the <code class="xref py py-attr docutils literal notranslate"><span class="pre">recursive</span></code> flag.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((a,b,c),(d,e,f,g)),(h,i,j));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#      ╭╴a</span>
<span class="c1">#    ╭─┼╴b</span>
<span class="c1">#  ╭─┤ ╰╴c</span>
<span class="c1">#  │ │ ╭╴d</span>
<span class="c1">#  │ ╰─┼╴e</span>
<span class="c1"># ─┤   ├╴f</span>
<span class="c1">#  │   ╰╴g</span>
<span class="c1">#  │ ╭╴h</span>
<span class="c1">#  ╰─┼╴i</span>
<span class="c1">#    ╰╴j</span>

<span class="n">polynode</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="n">polynode</span><span class="o">.</span><span class="n">resolve_polytomy</span><span class="p">(</span><span class="n">descendants</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#      ╭─┬╴a</span>
<span class="c1">#    ╭─┤ ╰╴b</span>
<span class="c1">#  ╭─┤ ╰╴c</span>
<span class="c1">#  │ │ ╭╴d</span>
<span class="c1">#  │ ╰─┼╴e</span>
<span class="c1"># ─┤   ├╴f</span>
<span class="c1">#  │   ╰╴g</span>
<span class="c1">#  │ ╭╴h</span>
<span class="c1">#  ╰─┼╴i</span>
<span class="c1">#    ╰╴j</span>

<span class="n">t</span><span class="o">.</span><span class="n">resolve_polytomy</span><span class="p">(</span><span class="n">descendants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#      ╭─┬╴a</span>
<span class="c1">#    ╭─┤ ╰╴b</span>
<span class="c1">#    │ ╰╴c</span>
<span class="c1">#  ╭─┤   ╭─┬╴d</span>
<span class="c1">#  │ │ ╭─┤ ╰╴e</span>
<span class="c1"># ─┤ ╰─┤ ╰╴f</span>
<span class="c1">#  │   ╰╴g</span>
<span class="c1">#  │ ╭─┬╴h</span>
<span class="c1">#  ╰─┤ ╰╴i</span>
<span class="c1">#    ╰╴j</span>
</pre></div>
</div>
</section>
<section id="tree-rooting">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">Tree rooting</a><a class="headerlink" href="#tree-rooting" title="Link to this heading">¶</a></h2>
<p>Tree rooting is understood as the technique by with a given tree is
conceptually polarized from more basal to more terminal nodes.</p>
<p>In phylogenetics, for instance, this a crucial step prior to the
interpretation of trees, since it will determine the evolutionary
relationships among the species involved.</p>
<p>The concept of rooted trees is different than just having a root node,
which is always necessary to handle a tree data structure. Usually,
the way in which a tree is differentiated between rooted and unrooted,
is by counting the number of branches of the current root node. Thus,
if the root node has more than two child branches, the tree is
considered unrooted. By contrast, when only two main branches exist
under the root node, the tree is considered rooted.</p>
<p>Having an unrooted tree means that any internal branch within the tree
could be regarded as the root node, and there is no conceptual reason
to place the root node where it is placed at the moment. Therefore, in
an unrooted tree, there is no information about which internal nodes
are more basal than others.</p>
<p>By setting the root node between a given edge/branch of the tree
structure the tree is polarized, meaning that the two branches under
the root node are the most basal nodes. In practice, this is usually
done by setting an <strong>outgroup node</strong>, which would represent one of
these main root branches. The second one will be, obviously, the
brother node. When you set an outgroup on unrooted trees, the
multifurcations at the current root node are solved.</p>
<p>In order to root an unrooted tree or re-root a tree structure, ETE
implements the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.set_outgroup" title="ete4.Tree.set_outgroup"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.set_outgroup()</span></code></a> method, which is present in
any tree node instance. Similarly, the <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.unroot" title="ete4.Tree.unroot"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.unroot()</span></code></a> method can
be used to perform the opposite action.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an unrooted tree. Note that 3 branches hang from the root</span>
<span class="c1"># node. This usually means that no information is available about</span>
<span class="c1"># which of the nodes is more basal.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(A,(H,F),(B,(E,D)));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#  ╭╴A</span>
<span class="c1"># ─┼─┬╴H</span>
<span class="c1">#  │ ╰╴F</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰─┬╴E</span>
<span class="c1">#      ╰╴D</span>

<span class="c1"># Let&#39;s define the ancestor of E and D as the tree outgroup.</span>
<span class="c1"># Of course, the definition of an outgroup will depend on user criteria.</span>
<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">ancestor</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># tree rooted at E and D&#39;s ancestor is more basal that the others</span>
<span class="c1">#  ╭─┬╴E</span>
<span class="c1"># ─┤ ╰╴D</span>
<span class="c1">#  ╰─┬╴B</span>
<span class="c1">#    ╰─┬╴A</span>
<span class="c1">#      ╰─┬╴H</span>
<span class="c1">#        ╰╴F</span>

<span class="c1"># Note that setting a different outgroup, a different interpretation</span>
<span class="c1"># of the tree is possible.</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># tree rooted at a terminal node</span>
<span class="c1">#  ╭╴A</span>
<span class="c1"># ─┤ ╭─┬╴H</span>
<span class="c1">#  ╰─┤ ╰╴F</span>
<span class="c1">#    ╰─┬╴B</span>
<span class="c1">#      ╰─┬╴E</span>
<span class="c1">#        ╰╴D</span>
</pre></div>
</div>
<p>Note that although <strong>rooting</strong> is usually regarded as a whole-tree
operation, ETE allows to root subparts of the tree without affecting
its parent tree structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s1">&#39;(((A,C),((H,F),(L,M))),((B,(J,K)),(E,D)));&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#    ╭─┬╴A</span>
<span class="c1">#  ╭─┤ ╰╴C</span>
<span class="c1">#  │ │ ╭─┬╴H</span>
<span class="c1">#  │ ╰─┤ ╰╴F</span>
<span class="c1"># ─┤   ╰─┬╴L</span>
<span class="c1">#  │     ╰╴M</span>
<span class="c1">#  │ ╭─┬╴B</span>
<span class="c1">#  ╰─┤ ╰─┬╴J</span>
<span class="c1">#    │   ╰╴K</span>
<span class="c1">#    ╰─┬╴E</span>
<span class="c1">#      ╰╴D</span>

<span class="c1"># Each main branch of the tree is independently rooted.</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>
<span class="n">node2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">common_ancestor</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>

<span class="n">node1</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
<span class="n">node2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># tree after rooting each node independently</span>
<span class="c1">#    ╭╴H</span>
<span class="c1">#  ╭─┤ ╭╴F</span>
<span class="c1">#  │ ╰─┤ ╭─┬╴L</span>
<span class="c1"># ─┤   ╰─┤ ╰╴M</span>
<span class="c1">#  │     ╰─┬╴A</span>
<span class="c1">#  │       ╰╴C</span>
<span class="c1">#  ╰─┬╴E</span>
<span class="c1">#    ╰─┬╴D</span>
<span class="c1">#      ╰─┬╴B</span>
<span class="c1">#        ╰─┬╴J</span>
<span class="c1">#          ╰╴K</span>
</pre></div>
</div>
</section>
<section id="working-with-branch-distances">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">Working with branch distances</a><a class="headerlink" href="#working-with-branch-distances" title="Link to this heading">¶</a></h2>
<p>The branch length between one node an its parent is encoded as the
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.dist" title="ete4.Tree.dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Tree.dist</span></code></a> property. Together with tree topology, branch
lengths define the relationships among nodes.</p>
<section id="getting-distances-between-nodes">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Getting distances between nodes</a><a class="headerlink" href="#getting-distances-between-nodes" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_distance" title="ete4.Tree.get_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_distance()</span></code></a> method can be used to calculate the
distance between two connected nodes. The method accepts as arguments
two descendant nodes.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a tree with branch lenght information.</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;(((A:1,B:2):1,C:3):1,</span>
<span class="s2">(((((D:0.5,I:0):0,F:0):0,G:0):0,H:0):0,E:0.2):3):2;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">],</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1">#    ╭─┬╴A</span>
<span class="c1">#  ╭─┤ ╰╴B</span>
<span class="c1">#  │ ╰╴C</span>
<span class="c1">#  │       ╭─┬╴D</span>
<span class="c1"># ─┤     ╭─┤ ╰╴I</span>
<span class="c1">#  │   ╭─┤ ╰╴F</span>
<span class="c1">#  │ ╭─┤ ╰╴G</span>
<span class="c1">#  ╰─┤ ╰╴H</span>
<span class="c1">#    ╰╴E</span>
<span class="c1">#            ╭╴1.0╶┬╴1.0</span>
<span class="c1">#      ╭╴1.0╶┤     ╰╴2.0</span>
<span class="c1">#      │     ╰╴3.0</span>
<span class="c1">#      │                       ╭╴0.0╶┬╴0.5</span>
<span class="c1"># ╴2.0╶┤                 ╭╴0.0╶┤     ╰╴0.0</span>
<span class="c1">#      │           ╭╴0.0╶┤     ╰╴0.0</span>
<span class="c1">#      │     ╭╴0.0╶┤     ╰╴0.0</span>
<span class="c1">#      ╰╴3.0╶┤     ╰╴0.0</span>
<span class="c1">#            ╰╴0.2</span>

<span class="c1"># Calculate distance between two nodes.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The distance between A and C is&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span>
<span class="c1"># The distance between A and C is 5.0</span>

<span class="c1"># Calculate the toplogical distance (number of nodes in between).</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The number of nodes between A and D is&#39;</span><span class="p">,</span>
      <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">topological</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># The number of nodes between A and D is 9</span>
</pre></div>
</div>
<p>Additionally to this, ETE incorporates two more methods to calculate
the most distant node from a given point in a tree. You can use the
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_farthest_node" title="ete4.Tree.get_farthest_node"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_farthest_node()</span></code></a> method to retrieve the most distant
point from a node within the whole tree structure. Alternatively,
<a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_farthest_leaf" title="ete4.Tree.get_farthest_leaf"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_farthest_leaf()</span></code></a> will return the most distant descendant
(always a leaf). If more than one node matches the farthest distance,
the first occurrence is returned.</p>
<p>Distance between nodes can also be computed as the number of nodes
between them (considering all branch lengths equal to 1.0). To do so,
use <code class="docutils literal notranslate"><span class="pre">topological=True</span></code> as an argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the farthest node from E within the whole structure.</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The farthest node from E is&#39;</span><span class="p">,</span> <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;with dist&#39;</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
<span class="c1"># The farthest node from E is B with dist 7.2</span>

<span class="c1"># Find the farthest node from E within the whole structure,</span>
<span class="c1"># regarding the number of nodes in between as distance value.</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">(</span><span class="n">topological</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The farthest (topologically) node from E is&#39;</span><span class="p">,</span>
      <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="s1">&#39;nodes in between&#39;</span><span class="p">)</span>
<span class="c1"># The farthest (topologically) node from E is D with 4.0 nodes in between</span>
</pre></div>
</div>
</section>
</section>
<section id="getting-midpoint-outgroup">
<span id="sub-getting-midpoint-outgroup"></span><h2><a class="toc-backref" href="#id38" role="doc-backlink">Getting midpoint outgroup</a><a class="headerlink" href="#getting-midpoint-outgroup" title="Link to this heading">¶</a></h2>
<p>In order to obtain a balanced rooting of the tree, you can set as the
tree outgroup that partition which splits the tree into two equally
distant clusters (using branch lengths). This is called the midpoint
outgroup.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete4.Tree.get_midpoint_outgroup" title="ete4.Tree.get_midpoint_outgroup"><code class="xref py py-func docutils literal notranslate"><span class="pre">Tree.get_midpoint_outgroup()</span></code></a> method will return the outgroup
partition that splits the current node into two balanced branches in
terms of node distances.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate a random tree.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># will look more or less like...</span>
<span class="c1">#    ╭─┬╴f</span>
<span class="c1">#  ╭─┤ ╰─┬╴g</span>
<span class="c1">#  │ │   ╰╴h</span>
<span class="c1">#  │ ╰─┬╴i</span>
<span class="c1">#  │   ╰╴j</span>
<span class="c1"># ─┤   ╭─┬╴k</span>
<span class="c1">#  │   │ ╰─┬╴l</span>
<span class="c1">#  │ ╭─┤   ╰╴m</span>
<span class="c1">#  │ │ │ ╭─┬╴n</span>
<span class="c1">#  ╰─┤ ╰─┤ ╰╴o</span>
<span class="c1">#    │   ╰─┬╴a</span>
<span class="c1">#    │     ╰╴b</span>
<span class="c1">#    ╰─┬╴c</span>
<span class="c1">#      ╰─┬╴d</span>
<span class="c1">#        ╰╴e</span>

<span class="c1"># Calculate the midpoint node.</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">()</span>

<span class="c1"># And set it as tree outgroup.</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># will look more or less like...</span>
<span class="c1">#      ╭─┬╴k</span>
<span class="c1">#      │ ╰─┬╴l</span>
<span class="c1">#    ╭─┤   ╰╴m</span>
<span class="c1">#    │ │ ╭─┬╴n</span>
<span class="c1">#  ╭─┤ ╰─┤ ╰╴o</span>
<span class="c1">#  │ │   ╰─┬╴a</span>
<span class="c1">#  │ │     ╰╴b</span>
<span class="c1"># ─┤ ╰─┬╴c</span>
<span class="c1">#  │   ╰─┬╴d</span>
<span class="c1">#  │     ╰╴e</span>
<span class="c1">#  │ ╭─┬╴f</span>
<span class="c1">#  ╰─┤ ╰─┬╴g</span>
<span class="c1">#    │   ╰╴h</span>
<span class="c1">#    ╰─┬╴i</span>
<span class="c1">#      ╰╴j</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ETE Toolkit</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorial</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Working with the Tree structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_phylogeny.html">Phylogenetic trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_smartview.html">Tree drawing and exploration (web)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_treeview.html">Tree drawing (Qt)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_taxonomy.html">Taxonomy databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_treematcher.html">Tree matcher</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faqs.html">Frequently Asked Questions</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tutorial</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Tutorial</a></li>
      <li>Next: <a href="tutorial_phylogeny.html" title="next chapter">Phylogenetic trees</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2008 - 2023, The ETE Toolkit Team.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/tutorial/tutorial_trees.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>